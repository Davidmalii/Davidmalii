Skip to content
Search or jump to…
Pull requests
Issues
Marketplace
Explore
 
@Davidmalii 
super0326
/
token-contract-based-erc20
1
00
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
first commit
 main
@super0326
super0326 committed on Apr 29 
1 parent c6283e5 commit 64225c9b8660aaf5ed4690d3d8c2fc0bb0e513cb
Showing  with 614 additions and 75 deletions.
 77  .gitignore 
@@ -1,76 +1,3 @@
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/
build/
package-lock.json
 72  README.md 
@@ -0,0 +1,72 @@
# token-sample-erc20

The purpose of this sample project is demonstrating [ERC20 token](https://eips.ethereum.org/EIPS/eip-20) contracts based on the awesome openzeppelin contract library, and features of the ERC20 token specification with truffel test scenarios.

## Token Contracts Demonstrated

The contracts with the features and tested scenarios are listed below.

#### Fixed Supply
```
contracts/ERC20FixedSupply.sol
constructor
  ✓ initialized with the correct supply (118ms)
  ✓ check the contract deployer is the new owner and has all the money (45ms)
adding spenders that can transfer money on behalf of the token owner
  ✓ current owner approves a new account to be the spender (60ms)
transfer
  ✓ current owner transfers to the spender (131ms)
  ✓ spender transfers from its own pocket to user1 (81ms)
  ✓ spender transfers from the custody account to user1 (109ms)
```

#### Mintable
```
contracts/ERC20MintableWithInitialSupply.sol
constructor
  ✓ initialized with the correct supply (144ms)
  ✓ check the contract deployer is the new owner and has all the money
adding spenders that can transfer money on behalf of the token owner
  ✓ current owner approves a new account to be the spender (50ms)
transfer
  ✓ current owner transfers to the spender (49ms)
  ✓ spender transfers from its own pocket to user1 (75ms)
  ✓ spender transfers from the custody account to user1 (96ms)
minters
  ✓ current owner is by default a minter and can mint more tokens out of thin air (60ms)
  ✓ current owner can add a new minter (60ms)
  ✓ a minter can make tokens as well (69ms)
  ✓ an altruistic minter can make tokens and give it to user1 (89ms)
```

#### Burnable
```
contracts/ERC20BurnableWithInitialSupply.sol
constructor
  ✓ initialized with the correct supply (109ms)
  ✓ check the contract deployer is the new owner and has all the money
adding spenders that can transfer money on behalf of the token owner
  ✓ current owner approves a new account to be the spender (92ms)
transfer
  ✓ current owner transfers to the spender (61ms)
  ✓ spender transfers from its own pocket to user1 (119ms)
  ✓ spender transfers from the custody account to user1 (164ms)
burn baby burn!
  ✓ current owner can burn tokens (117ms)
  ✓ spender can also burn its own tokens (84ms)
  ✓ spender can also burn tokens from its allowance (104ms)
```

## Getting Started

Instal [truffle](https://truffleframework.com/truffle)

Install [Ganache](https://truffleframework.com/ganache) and start it

```
npm i
truffle test
``` 
 15  contracts/ERC20BurnableWithInitialSupply.sol 
@@ -0,0 +1,15 @@
pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";

contract ERC20BurnableWithInitialSupply is ERC20Burnable, ERC20Detailed, Ownable {
  constructor()
    Ownable()
    ERC20Detailed("Example ERC20 Token With Initial Supply Of 1 Million And Burnable", "Burnable", 18)
    ERC20Burnable()
    public {
    _mint(super.owner(), 1000000 * 10**uint(super.decimals()));
  }
} 
 15  contracts/ERC20FixedSupply.sol 
@@ -0,0 +1,15 @@
pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";

contract ERC20FixedSupply is ERC20, ERC20Detailed, Ownable {
  constructor()
    Ownable()
    ERC20Detailed("Example Fixed Supply Token", "FIXED", 18)
    ERC20()
    public {
    _mint(super.owner(), 1000000 * 10**uint(super.decimals()));
  }
} 
 15  contracts/ERC20MintableWithInitialSupply.sol 
@@ -0,0 +1,15 @@
pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";

contract ERC20MintableWithInitialSupply is ERC20Mintable, ERC20Detailed, Ownable {
  constructor()
    Ownable()
    ERC20Detailed("Example ERC20 Token With Initial Supply Of 1 Million And Mintable", "Mintable", 18)
    ERC20Mintable()
    public {
    _mint(super.owner(), 1000000 * 10**uint(super.decimals()));
  }
} 
 23  contracts/Migrations.sol 
@@ -0,0 +1,23 @@
pragma solidity >=0.4.21 <0.6.0;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}
 5  migrations/1_initial_migration.js 
@@ -0,0 +1,5 @@
var Migrations = artifacts.require("./Migrations.sol");

module.exports = function(deployer) {
  deployer.deploy(Migrations);
};
 7  migrations/2_deploy_contracts.js 
@@ -0,0 +1,7 @@
const FixedSupply = artifacts.require("./ERC20FixedSupply.sol");
const Mintable = artifacts.require("./ERC20MintableWithInitialSupply.sol");

module.exports = function (deployer) {
  deployer.deploy(FixedSupply);
  deployer.deploy(Mintable);
}; 
 27  package.json 
@@ -0,0 +1,27 @@
{
  "name": "fixed-supply-token",
  "version": "1.0.0",
  "description": "",
  "main": "truffle-config.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "address": "truffle exec addresses.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "Apache-2.0",
  "devDependencies": {
    "bignumber.js": "^6.0.0",
    "truffle": "^5.0.0",
    "truffle-assertions": "^0.8.0"
  },
  "dependencies": {
    "ethereumjs-util": "^5.1.5",
    "openzeppelin-solidity": "2.1.2",
    "truffle-contract": "^3.0.5",
    "truffle-hdwallet-provider": "0.0.3",
    "web3": "^1.0.0-beta.34"
  }
}
 137  test/ERC20Burnable.js 
@@ -0,0 +1,137 @@
let TokenContract = artifacts.require('ERC20BurnableWithInitialSupply');

const truffleAssert = require('truffle-assertions');

contract("Burnable Tokens", async (accounts) => {
  const TotalSupply = '1000000000000000000000000';
  let myContract, currentOwner, spender, user1;

  before(() => {
    currentOwner = accounts[0];
    spender = accounts[1];
    user1 = accounts[2];
  });

  describe("constructor", async() => {
    it("initialized with the correct supply", async() => {
      myContract = await TokenContract.new();
      let supply = await myContract.totalSupply();
      // one million with 18 decimals
      expect(supply.toString()).to.equal(TotalSupply);

      const transactionHash = myContract.transactionHash;

      const transactionReceipt = web3.eth.getTransactionReceipt(transactionHash);
      const blockNumber = transactionReceipt.blockNumber;

      const eventList = await myContract.getPastEvents("allEvents", {fromBlock: blockNumber, toBlock: blockNumber});
      const events = eventList.filter(ev => ev.transactionHash === transactionHash);
      expect(events.length).to.equal(2); // OwnershipTransferred by Ownable, and Transfer by ERC20
      expect(events[1].args.value.toString()).to.equal(TotalSupply);

      currentOwner = events[1].args.to;
    });

    it("check the contract deployer is the new owner and has all the money", async () => {
      let ownerBalance = await myContract.balanceOf(currentOwner);
      expect(ownerBalance.toString()).to.equal(TotalSupply);
    });
  });

  describe('adding spenders that can transfer money on behalf of the token owner', () => {
    it('current owner approves a new account to be the spender', async () => {
      let result = await myContract.approve(spender, 1000000);

      truffleAssert.eventEmitted(result, 'Approval', ev => {
        return ev.owner === currentOwner && ev.spender === spender;
      }, `Add allowance to ${spender}`);

      let allowance = await myContract.allowance(currentOwner, spender);
      expect(allowance.toString()).to.equal('1000000');
    });
  });

  describe('transfer', () => {
    it('current owner transfers to the spender', async () => {
      let result = await myContract.transfer(spender, 1000);

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === spender;
      }, `Transfer to ${spender}`);

      let balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('1000');
    });

    it('spender transfers from its own pocket to user1', async () => {
      let result = await myContract.transfer(user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === spender && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
    });

    it('spender transfers from the custody account to user1', async () => {
      let result = await myContract.transferFrom(currentOwner, user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('1000');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999998500');
    });
  });

  describe('burn baby burn!', () => {
    it('current owner can burn tokens', async () => {
      let result = await myContract.burn(1000);

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === '0x0000000000000000000000000000000000000000';
      }, `Burn my own tokens`);

      let balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999997500');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('999999999999999999999000');
    });

    it('spender can also burn its own tokens', async () => {
      let result = await myContract.burn(100, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === spender && ev.to === '0x0000000000000000000000000000000000000000';
      }, `Burn my own tokens`);

      let balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('400');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('999999999999999999998900');
    });

    it('spender can also burn tokens from its allowance', async () => {
      let result = await myContract.burnFrom(currentOwner, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === '0x0000000000000000000000000000000000000000';
      }, `Burn allowed tokens`);

      let balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('400'); // stays the same since spender didn't burn its own tokens
      balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999997000');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('999999999999999999998400');
    });
  });
}); 
 94  test/ERC20FixedSupply.js 
@@ -0,0 +1,94 @@
let TokenContract = artifacts.require('ERC20FixedSupply');

const truffleAssert = require('truffle-assertions');

contract("FixedSupplyToken", async (accounts) => {
  const TotalSupply = '1000000000000000000000000';
  let myContract, currentOwner, spender, user1;

  before(() => {
    currentOwner = accounts[0];
    spender = accounts[1];
    user1 = accounts[2];
  });

  describe("constructor", async() => {
    it("initialized with the correct supply", async() => {
      myContract = await TokenContract.new();
      let supply = await myContract.totalSupply();
      // one million with 18 decimals
      expect(supply.toString()).to.equal(TotalSupply);

      const transactionHash = myContract.transactionHash;

      const transactionReceipt = web3.eth.getTransactionReceipt(transactionHash);
      const blockNumber = transactionReceipt.blockNumber;

      const eventList = await myContract.getPastEvents("allEvents", {fromBlock: blockNumber, toBlock: blockNumber});
      const events = eventList.filter(ev => ev.transactionHash === transactionHash);
      expect(events.length).to.equal(2); // OwnershipTransferred by Ownable, and Transfer by ERC20
      expect(events[1].args.value.toString()).to.equal(TotalSupply);

      currentOwner = events[1].args.to;
    });

    it("check the contract deployer is the new owner and has all the money", async () => {
      let ownerBalance = await myContract.balanceOf(currentOwner);
      expect(ownerBalance.toString()).to.equal(TotalSupply);
    });
  });

  describe('adding spenders that can transfer money on behalf of the token owner', () => {
    it('current owner approves a new account to be the spender', async () => {
      let result = await myContract.approve(spender, 1000000);

      truffleAssert.eventEmitted(result, 'Approval', ev => {
        return ev.owner === currentOwner && ev.spender === spender;
      }, `Add allowance to ${spender}`);

      let allowance = await myContract.allowance(currentOwner, spender);
      expect(allowance.toString()).to.equal('1000000');
    });
  });

  describe('transfer', () => {
    it('current owner transfers to the spender', async () => {
      let result = await myContract.transfer(spender, 1000);

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === spender;
      }, `Transfer to ${spender}`);

      let balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('1000');
    });

    it('spender transfers from its own pocket to user1', async () => {
      let result = await myContract.transfer(user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === spender && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
    });

    it('spender transfers from the custody account to user1', async () => {
      let result = await myContract.transferFrom(currentOwner, user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('1000');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999998500');
    });
  });
}); 
 149  test/ERC20Mintable.js 
@@ -0,0 +1,149 @@
let TokenContract = artifacts.require('ERC20MintableWithInitialSupply');

const truffleAssert = require('truffle-assertions');

contract("Mintable Token", async (accounts) => {
  const InitialSupply = '1000000000000000000000000';
  let myContract, currentOwner, spender, user1, minter;

  before(() => {
    currentOwner = accounts[0];
    spender = accounts[1];
    user1 = accounts[2];
    minter = accounts[3];
  });

  describe("constructor", async() => {
    it("initialized with the correct supply", async() => {
      myContract = await TokenContract.new();
      let supply = await myContract.totalSupply();
      // one million with 18 decimals
      expect(supply.toString()).to.equal(InitialSupply);

      const transactionHash = myContract.transactionHash;

      const transactionReceipt = web3.eth.getTransactionReceipt(transactionHash);
      const blockNumber = transactionReceipt.blockNumber;

      const eventList = await myContract.getPastEvents("allEvents", {fromBlock: blockNumber, toBlock: blockNumber});
      const events = eventList.filter(ev => ev.transactionHash === transactionHash);
      expect(events.length).to.equal(3); // OwnershipTransferred by Ownable, and Transfer by ERC20, MinterAdded by MinterRole
      expect(events[2].args.value.toString()).to.equal(InitialSupply);

      currentOwner = events[2].args.to;
    });

    it("check the contract deployer is the new owner and has all the money", async () => {
      let ownerBalance = await myContract.balanceOf(currentOwner);
      expect(ownerBalance.toString()).to.equal(InitialSupply);
    });
  });

  describe('adding spenders that can transfer money on behalf of the token owner', () => {
    it('current owner approves a new account to be the spender', async () => {
      let result = await myContract.approve(spender, 1000000);

      truffleAssert.eventEmitted(result, 'Approval', ev => {
        return ev.owner === currentOwner && ev.spender === spender;
      }, `Add allowance to ${spender}`);

      let allowance = await myContract.allowance(currentOwner, spender);
      expect(allowance.toString()).to.equal('1000000');
    });
  });

  describe('transfer', () => {
    it('current owner transfers to the spender', async () => {
      let result = await myContract.transfer(spender, 1000);

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === spender;
      }, `Transfer to ${spender}`);

      let balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('1000');
    });

    it('spender transfers from its own pocket to user1', async () => {
      let result = await myContract.transfer(user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === spender && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
    });

    it('spender transfers from the custody account to user1', async () => {
      let result = await myContract.transferFrom(currentOwner, user1, 500, { from: spender });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === currentOwner && ev.to === user1;
      }, `Transfer to ${user1}`);

      let balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('1000');
      balance = await myContract.balanceOf(spender);
      expect(balance.toString()).to.equal('500');
      balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999998500');
    });
  });

  describe('minters', () => {
    it('current owner is by default a minter and can mint more tokens out of thin air', async () => {
      let result = await myContract.mint(currentOwner, 1000);

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === '0x0000000000000000000000000000000000000000' && ev.to === currentOwner;
      }, `Mint some tokens and give to myself`);

      let balance = await myContract.balanceOf(currentOwner);
      expect(balance.toString()).to.equal('999999999999999999999500');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('1000000000000000000001000');
    });

    it('current owner can add a new minter', async () => {
      let result = await myContract.addMinter(minter);

      truffleAssert.eventEmitted(result, 'MinterAdded', ev => {
        return ev.account === minter;
      }, `Add a minter`);

      let isMinter = await myContract.isMinter(minter);
      expect(isMinter).to.be.true;
    });

    it('a minter can make tokens as well', async () => {
      let result = await myContract.mint(minter, 1000, { from: minter });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === '0x0000000000000000000000000000000000000000' && ev.to === minter;
      }, `Mint some tokens and give to myself`);

      let balance = await myContract.balanceOf(minter);
      expect(balance.toString()).to.equal('1000');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('1000000000000000000002000');
    });

    it('an altruistic minter can make tokens and give it to user1', async () => {
      let result = await myContract.mint(user1, 1000, { from: minter });

      truffleAssert.eventEmitted(result, 'Transfer', ev => {
        return ev.from === '0x0000000000000000000000000000000000000000' && ev.to === user1;
      }, `Mint some tokens and give to user1`);

      let balance = await myContract.balanceOf(minter);
      expect(balance.toString()).to.equal('1000');
      balance = await myContract.balanceOf(user1);
      expect(balance.toString()).to.equal('2000');
      balance = await myContract.totalSupply();
      expect(balance.toString()).to.equal('1000000000000000000003000');
    });
  });
}); 
 53  truffle-config.js 
@@ -0,0 +1,53 @@

module.exports = {
  /**
   * Networks define how you connect to your ethereum client and let you set the
   * defaults web3 uses to send transactions. If you don't specify one truffle
   * will spin up a development blockchain for you on port 9545 when you
   * run `develop` or `test`. You can ask a truffle command to use a specific
   * network from the command line, e.g
   *
   * $ truffle test --network <network-name>
   */

  networks: {
    // Useful for testing. The `development` name is special - truffle uses it by default
    // if it's defined here and no other network is specified at the command line.
    // You should run a client (like ganache-cli, geth or parity) in a separate terminal
    // tab if you use this network and you must also set the `host`, `port` and `network_id`
    // options below to some value.
    //
    development: {
     host: "127.0.0.1",     // default for Ganache
     port: 7545,            // default for Ganache
     network_id: "*"        // Any network (default: none)
    },
    // default for a local setup based on
    // https://hackernoon.com/setup-your-own-private-proof-of-authority-ethereum-network-with-geth-9a0a3750cda8
    local: {
     host: "localhost",
     port: 22001,
     network_id: "*"
    }
  },

  // Set default mocha options here, use special reporters etc.
  mocha: {
    // timeout: 100000
  },

  // Configure your compilers
  compilers: {
    solc: {
      // version: "0.5.1",    // Fetch exact version from solc-bin (default: truffle's version)
      // docker: true,        // Use "0.5.1" you've installed locally with docker (default: false)
      // settings: {          // See the solidity docs for advice about optimization and evmVersion
      //  optimizer: {
      //    enabled: false,
      //    runs: 200
      //  },
      //  evmVersion: "byzantium"
      // }
    }
  }
}
0 comments on commit 64225c9
@Davidmalii
 
 
Leave a comment
No file chosen
Attach files by dragging & dropping, selecting or pasting them.
 You’re not receiving notifications from this thread.
© 2021 GitHub, Inc.
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
Loading complete
